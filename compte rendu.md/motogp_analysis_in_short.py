# -*- coding: utf-8 -*-
"""motogp-analysis-in-short.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-kYCtJ21LY9OQPAkjTYN2OTKZCIyS5II

# <center style="color:red;">About MotoGP :</center>
"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# from IPython.display import Image
# Image(filename='../input/images2/download (1).png', width=800, height=600)

"""Grand Prix motorcycle racing is the premier class of motorcycle road racing events held on road circuits sanctioned by the Fédération Internationale de Motocyclisme (FIM). Independent motorcycle racing events have been held since the start of the twentieth century and large national events were often given the title Grand Prix.  The foundation of the Fédération Internationale de Motocyclisme as the international governing body for motorcycle sport in 1949 provided the opportunity to coordinate rules and regulations in order that selected events could count towards official World Championships. It is the oldest established motorsport world championship.


Grand Prix motorcycles are purpose-built racing machines that are unavailable for purchase by the general public and unable to be ridden legally on public roads. This contrasts with the various production-based categories of racing, such as the Superbike World Championship and the Isle of Man TT Races that feature modified versions of road-going motorcycles available to the public. The current top division is known as MotoGP since 2002
"""

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

import matplotlib.pyplot as plt
import seaborn as sns

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

!pip install pygal
!pip install squarify

import plotly as plot
import pygal as py
import squarify as sq
import matplotlib
plt.rcParams["figure.figsize"] = (20,15)
matplotlib.rc('xtick', labelsize=7)
matplotlib.rc('ytick', labelsize=7)

font = {'family' : 'normal',
        'weight' : 'bold',
        'size'   : 5}

matplotlib.rc('font', **font)

"""# <center style="color:red;">Data Preparation :</center>"""

mt=pd.read_csv("../input/motogp-all-time-riders/motogp_allriders.csv",engine="python",encoding='latin-1')

# Commented out IPython magic to ensure Python compatibility.
# %%time
# mt
# 
# mt.style.highlight_null(null_color="red")

mt1=mt.fillna(0)

from PIL import Image,ImageFont,ImageDraw

im1 = Image.open("../input/images2/images-_1_.jpeg")
im2 = Image.open("../input/images2/download-_21_.jpeg")
im3 = Image.open("../input/images2/images-_19_ (1).jpg")
im4 = Image.open("../input/images2/download-_22_.jpeg")
im5 = Image.open("../input/images2/download-_23_.jpeg")


def get_concat_h_cut(im1,im2,img3,im4,im5):
    dst = Image.new('RGB', (im1.width + im2.width + im3.width + im4.width + im5.width, min(im1.height, im2.height,im3.height,im4.height+im5.height)))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    dst.paste(im3,(im1.width+im2.width,0))
    dst.paste(im4,(im1.width+im2.width+im3.width,0))
    dst.paste(im5,(im1.width+im2.width+im3.width+im4.width,0))
    return dst

def get_concat_v_cut(im1,im2,img3,im4,im5):
    dst = Image.new('RGB', (min(im1.width, im2.width), im1.height + im2.height))
    dst.paste(im1, (0, 0))
    dst.paste(im2, (0, im1.height))
    return dst

NEW_img=get_concat_h_cut(im1,im2,im3,im4,im5)
NEW_img.save('pillow_concat_h_cut.jpg')

img = Image.open("../input/photo2/pillow_concat_h_cut.jpg")
draw = ImageDraw.Draw(img)
#font = ImageFont.truetype("../input/fontsttf/AlfaSlabOne-Regular.ttf", 10)
draw.text((450, 0),"Top 5 Players in Moto gp's history",(0,0,0)) # this will draw text with Blackcolor and 16 size
img

"""# <center style="color:red;">Exploratory Data Analysis :</center>"""

from wordcloud import WordCloud, STOPWORDS
comment_words = ''
stopwords = set(STOPWORDS)

# iterate through the csv file
for val in mt.Name:

    # typecaste each val to string
    val = str(val)

    # split the value
    tokens = val.split()

    # Converts each token into lowercase
    for i in range(len(tokens)):
        tokens[i] = tokens[i].lower()

    comment_words += " ".join(tokens)+" "

wordcloud = WordCloud(width = 800, height = 800,
                background_color ='white',
                stopwords = stopwords,
                min_font_size = 10).generate(comment_words)

# plot the WordCloud image
plt.figure(figsize = (8, 8), facecolor = None)
plt.imshow(wordcloud)
plt.axis("off")
plt.tight_layout(pad = 0)

plt.show()

mt.shape

mt.describe().transpose()

mt.info()

mt.dtypes

mt.plot.box()

mt.plot.barh(x="Name",y="victories",color="red",alpha=0.80);plt.xlabel("victories");plt.ylabel("Name of Players");
plt.title("Victories by Players");plt.show()

mt[mt["World Championships"]>0].plot(x="Name",y="World Championships",kind="bar",color="green")
plt.xlabel("Player name")
plt.ylabel("No . of world campionships")
plt.title("No. of world title won by players",fontsize=10,pad=5)
plt.show()

w_c = mt[mt["World Championships"]>0]

#Utilise matplotlib to scale our goal numbers between the min and max, then assign this scale to our values.
norm = matplotlib.colors.Normalize(vmin=min(w_c["World Championships"]), vmax=max(w_c["World Championships"]))
colors = [matplotlib.cm.Blues(norm(value)) for value in w_c["World Championships"]]

#Create our plot and resize it.
fig = plt.gcf()
ax = fig.add_subplot()

#Use squarify to plot our data, label it and add colours. We add an alpha layer to ensure black labels show through
sq.plot(label=w_c.Name,sizes=w_c.victories, color = colors, alpha=.6,pad = True)
plt.title("Moto gp championships winner with thier sizes showing victories",fontsize=23,fontweight="bold")
#Remove our axes and display the plot
plt.axis('off')
plt.show()

df_mt=mt.drop(columns=["pole positions from '74 to 2021","race fastest lap to 2021","World Championships"])

df_mt.plot(x='Name', kind='bar', stacked=True,
        title='Stacked Bar Graph by dataframe')

plt.xlabel("Name of moto gp players");plt.ylabel("WINNERS in 1 st,2nd,3rd position")
plt.show()

line_chart = py.StackedBar()
line_chart.title = 'Browser usage evolution (in %)'
line_chart.add('victories', mt1["victories"].to_list())
line_chart.add('Championships',mt1["World Championships"].to_list())
line_chart.render_in_browser()

total = sum(mt1["victories"])
data = [sum(mt1["victories"].head(10)),sum(mt1["victories"])-sum(mt1["victories"].head(10))]


# Setting size in Chart based on
# given values
sizes = data

# Setting labels for items in Chart
labels = ['top 10 player victories', 'Other players victories']

# colors
colors = ['green', 'yellow']

# explosion
explode = (0.05, 0.05)

# Pie Chart
plt.pie(sizes, colors=colors, labels=labels,autopct='%1.1f%%', pctdistance=0.85,explode=explode)

# draw circle
centre_circle = plt.Circle((0, 0), 0.70, fc='white')
fig = plt.gcf()

# Adding Circle in Pie chart
fig.gca().add_artist(centre_circle)

# Adding Title of chart
plt.title('Victories of top 10 players vs other players')

# Add Legends
plt.legend(labels, loc="upper left", title="Comparision of top players vs others")

# Displaing Chart
plt.show()

mt1.iloc[:,0:4].style.bar(subset=['victories', '2nd places',"3rd places"], color='#d65f5f')

corr=mt.corr()
corr.style.highlight_max(color="red",axis=1)

sns.heatmap(corr)

pip install klib

import klib

klib.corr_plot(mt, split='pos') # displaying only positive correlations, other settings include threshold, cmap...

klib.dist_plot(mt) # default representation of a distribution plot, other settings include fill_range, histogram, ...
plt.show()

klib.cat_plot(mt, top=4, bottom=4) # representation of the 4 most & least common values in each categorical column ;
plt.show()

plt.figure(facecolor="olive",edgecolor="green")
sns.set_palette( 'inferno_r')
sns.set_style("darkgrid")
mt2=mt1.sort_values(by="victories",ascending=False).head(10)
mt3=mt1.sort_values(by="2nd places",ascending=False).head(10)
mt4=mt1.sort_values(by="3rd places",ascending=False).head(10)
mt5=mt1.sort_values(by="World Championships",ascending=False).head(10)
fig, axes = plt.subplots(4,1)
fig.suptitle('Players top in their positions')


sns.barplot(ax=axes[0], x=mt2.Name, y=mt2.victories)
axes[0].set_title("players with highest victories")


sns.barplot(ax=axes[1], x=mt3.Name, y=mt3["2nd places"])
axes[1].set_title("Players with most no. of 2 nd positions")


sns.barplot(ax=axes[2], x=mt4.Name, y=mt4["3rd places"])
axes[2].set_title("Players with most no. of 3rd positions")

sns.barplot(ax=axes[3], x=mt5.Name, y=mt5["World Championships"])
axes[3].set_title("Players with most no. of World Campionships")

plt.xticks(rotation=90)
plt.show()

sns.pairplot(mt1,palette="rainbow",corner=True,plot_kws=dict(marker="+", linewidth=1),
    diag_kws=dict(fill=False));plt.show()

import plotly.graph_objects as go

categories = list(mt1["Name"])

fig = go.Figure()

fig.add_trace(go.Scatterpolar(
      r=mt1["victories"].tolist(),
      theta=categories,
      fill='toself',
      name='1st place'
))
fig.add_trace(go.Scatterpolar(
      r=mt1["2nd places"].tolist(),
      theta=categories,
      fill='toself',
      name='2nd place'
))

fig.add_trace(go.Scatterpolar(
      r=mt1["3rd places"].tolist(),
      theta=categories,
      fill='toself',
      name='3rd Place'
))

fig.add_trace(go.Scatterpolar(
      r=mt1["World Championships"].tolist(),
      theta=categories,
      fill='toself',
      name='World champoionships'
))

fig.update_layout(
     font=dict(
        family="Courier New, monospace",
        size=6,
        color="RebeccaPurple"
    ),
  polar=dict(
    radialaxis=dict(
      visible=True,
      range=[0, 90],

    )),
  showlegend=True
)

fig.show()

import plotly.express as px
fig = px.box(mt1, y="race fastest lap to 2021", points="all",notched=True)
fig.show()

fig = go.Figure()
# Use x instead of y argument for horizontal plot
fig.add_trace(go.Box(x=mt1["victories"],name='1st places'))
fig.add_trace(go.Box(x=mt1["2nd places"],name="2nd places"))
fig.add_trace(go.Box(x=mt1["3rd places"],name="3rd place"))
fig.add_trace(go.Box(x=mt1["World Championships"],name="World Championships"))

fig.update_layout(title_text="Box ploting players position in given data")
fig.update_traces(orientation='h')
fig.show()

fig = px.pie(mt1[mt1["World Championships"]>0], values='World Championships', names='Name', title='championships won the players')
fig.show()

fig = px.scatter(mt1, x="pole positions from '74 to 2021", y="World Championships", size='victories',color="race fastest lap to 2021")
fig.show()

sns.lmplot(data=mt1, x="pole positions from '74 to 2021", y="World Championships",markers=["*"],palette="Set1")

fig2= px.treemap(data_frame=mt1, path=["Name","victories","2nd places","3rd places"],
                values='victories',color='World Championships', hover_data=["race fastest lap to 2021"],color_continuous_scale='RdBu',
                color_continuous_midpoint=np.average(mt1["World Championships"], weights=mt1['victories']))
fig2.update_traces(root_color="cyan")
fig2.update_layout(margin = dict(t=50, l=25, r=25, b=25))
fig2.show()

"""#### Using Naive Bayes algorithm for finding the championship won or not using no.of pole positions and victories."""

w_v_m=mt1.drop(columns=["2nd places","3rd places","race fastest lap to 2021","Name"])
w_v_m.loc[w_v_m['World Championships'] <= 0, 'Won Championship or not?'] = 'False'
w_v_m.loc[w_v_m['World Championships'] > 0, 'Won Championship or not?'] = 'True'
# Using 'Address' as the column name
# and equating it to the list
w_v_m

X=w_v_m.iloc[:,:2]
y=w_v_m["Won Championship or not?"]

# splitting X and y into training and testing sets
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=1)

# training the model on training set
from sklearn.naive_bayes import GaussianNB
gnb = GaussianNB()
gnb.fit(X_train, y_train)

# making predictions on the testing set
y_pred = gnb.predict(X_test)

# comparing actual response values (y_test) with predicted response values (y_pred)
from sklearn import metrics
print("Gaussian Naive Bayes model accuracy(in %):", metrics.accuracy_score(y_test, y_pred)*100)

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, fbeta_score

# Accuracy
accuracy_score(y_test, y_pred)

from sklearn.metrics import confusion_matrix

expected = y_test
predicted = y_pred
results = confusion_matrix(expected, predicted)
print(results)

plt.figure(figsize=[8,8]);sns.heatmap(results,annot=True);plt.show()

y_pred = gnb.predict([[5,10]]) #example of one prediction example
y_pred

"""# <center style="color:red;">Conclusions:</center>

> 1.**ROSSI Valentino** has most no. of victories on 1st,2nd ,3rd positions.
>
> 2.But ROSSI Valentino didn't won most no. championships.**AGOSTINI Giacomo** is the one that won most of the world championships.
>
> 3.Top 5 players are :
>     a. ROSSI Valentino	b.AGOSTINI Giacomo	c.MARQUEZ Marc	d. DOOHAN Mick	e.LORENZO Jorge
>
> 4.Approx 40% of championships were win by these top seeded players.
>
> 5.More than 50% victories were clinched by top 10 players.
>
> 6.winning the championship is much more difficult than getting a victories,2nd place or the 3rd place.
>
> 7.as no.of pole positions increased chances of winning the world championships and getting victories also increased.
>
> 8.Only 27 out of 115 players won all world championships.
>
> 9.Race 's fastest lap comes early at the start of the race.
>
> 10.World championships depend upon no.of pole positions and victories.
>
> 11.Rossi valentino and Jorge Lorenzo are among the consistent players for top 5 players.
"""